=======================================
Лабораторна робота №5-6. Символьний девайс
=======================================

Постановка задачі:
-------------------
Модифікувати вихідний приклад:

- додати ініціалізацію пам'яті девайсу нульовими символами
- додати механізми читання і запису в девайсі
- додати можливість додавання пристрою в  **dev** 
- додати операції з ``ioctl``, які додають в буфер "магічний" рядок і дозволяють задавати розмір буфера

Теоретичний матеріал
-------------------
Символьний пристрій - це пристрій, до яких можна звертатись як до потоку байтів.
Так як ми створюємо символьний пристрій у навчальних цілях, наш девайс буде виконувати операції лише з пам'яттю системи (scull).
Драйвер повинен підтримувати мінімальний набір операцій:

- open - відкриття файлового дескриптору
- read -  считування інформації з потоку байт
- write - запис інформації у поток байт
- lseek - пересування курсору на вказану позицію у потоці байт
- ioctl - виконує операції з форматування потоку байт (збільшення буферу, додавання специфічного масиву байт, тощо).
 
Для зберігання номерів девайсів, молодшого та старшого, у ядрі використовується тип ``dev_t``. 
Починаючи з версії ядра 2.6.0, dev_t є 32-х розрядним, 12 біт відведені для старшого номеру та 20 - для молодшого.
Для отримання старшой і молодшой частини ``dev_t`` можна використовувати:

   .. code-block:: C
   
    MAJOR(dev_t dev); 
    MINOR(dev_t dev);
    
Або якщо вже є молодший та старший номер девайсу можна скористатись функцією ``dev_t``:
  
  .. code-block:: C
  
    MKDEV(int major, int minor);

Одним з перших кроків, який потрібно здійснити драйверу символьного девайсу є отримання номерів приладів, для роботи з ними, необхідною функцією для виконання задачі є ``register_chrdev_region``, яка об'явлена у ``<linux/fs.h>``: 

    .. code-block:: C
    
        int register_chrdev_region(dev_t first, unsigned int count, char *name);

Але, коли немає можливості знати, які старші номера будуть використовуватись, ядро може виділити старший номер самостійно, для цього використовується інша функція:

    .. code-block:: C
    
        int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
        
Одне із завдань передбачало заміну основного функціоналу запису інформації - списку(linked list) на один із наведених викладачем : 
Асоціативний масив або дерево.
Мною було обрано червоно-чорне дерево - rbt(red-black tree)

Червоно-чорні дерева - це тип самобалансованого бінарного дерева пошуку, який використовується для зберігання даних. 
Червоно-чорні дерева схожі на дерева AVL, забезпечують більш швидку вставку та видалення, але повільніший пошук .

Виконання роботи
----------------

Було модифіковано вихідний код, наданий викладачем. Додано механізм зчитування та запису у буфер `` cdev_write`` та `` cdev_read``
Написані функція пошуку у буфері `` cdev_lseek`` та функція форматування буфера `` cdev_ioctl``.
Написані функції врапери(wrappers) які використовують *API* ядра, що дозволяють проводити запис у червоно-чорне дерево, а також зчитування та видалення елементів з дерева.
Створено тестову програму, яка створює файловий дескриптор, відкриває його, пише\зчитує в\з нього дані, змінює розмір буферу, та прикріплює до буферу магічну фразу.



