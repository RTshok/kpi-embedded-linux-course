=======================================
Лабораторна робота №5-6. Символьний девайс
=======================================

Постановка задачі:
-------------------
Модифікувати вихідний приклад:

- додати ініціалізацію пам'яті девайсу нульовими символами
- додати механізми читання і запису в девайсі
- додати можливість додавання пристрою в  **dev** 
- додати операції з ``ioctl``, які додають в буфер "магічний" рядок і дозволяють задавати розмір буфера

Теоретичний матеріал
-------------------
Символьний пристрій - це пристрій, до яких можна звертатись як до потоку байтів.
Так як ми створюємо символьний пристрій у навчальних цілях, наш девайс буде виконувати операції лише з пам'яттю системи (scull).
Драйвер повинен підтримувати мінімальний набір операцій:

- open - відкриття файлового дескриптору
- read -  считування інформації з потоку байт
- write - запис інформації у поток байт
- lseek - пересування курсору на вказану позицію у потоці байт
- ioctl - виконує операції з форматування потоку байт (збільшення буферу, додавання специфічного масиву байт, тощо).
 
Для зберігання номерів девайсів, молодшого та старшого, у ядрі використовується тип ``dev_t``. 
Починаючи з версії ядра 2.6.0, dev_t є 32-х розрядним, 12 біт відведені для старшого номеру та 20 - для молодшого.
Для отримання старшой і молодшой частини ``dev_t`` можна використовувати:

   .. code-block:: C
   
    MAJOR(dev_t dev); 
    MINOR(dev_t dev);
    
Або якщо вже є молодший та старший номер девайсу можна скористатись функцією ``dev_t``:
  
  .. code-block:: C
  
    MKDEV(int major, int minor);

Одним з перших кроків, який потрібно здійснити драйверу символьного девайсу є отримання номерів приладів, для роботи з ними, необхідною функцією для виконання задачі є ``register_chrdev_region``, яка об'явлена у ``<linux/fs.h>``: 

    .. code-block:: C
    
        int register_chrdev_region(dev_t first, unsigned int count, char *name);

Але, коли немає можливості знати, які старші номера будуть використовуватись, ядро може виділити старший номер самостійно, для цього використовується інша функція:

    .. code-block:: C
    
        int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
        
Одне із завдань передбачало заміну основного функціоналу запису інформації - списку(linked list) на один із наведених викладачем : 
Асоціативний масив або дерево.
Мною було обрано червоно-чорне дерево - rbt(red-black tree)

Червоно-чорні дерева - це тип самобалансованого бінарного дерева пошуку, який використовується для зберігання даних. 
Червоно-чорні дерева схожі на дерева AVL, забезпечують більш швидку вставку та видалення, але повільніший пошук .

Виконання роботи
----------------

Було модифіковано вихідний код, наданий викладачем. Додано механізм зчитування та запису у буфер ``cdev_write`` та ``cdev_read``
Написані функція пошуку у буфері ``cdev_lseek`` та функція форматування буфера ``cdev_ioctl`` .
Написані функції врапери(wrappers) які використовують *API* ядра, що дозволяють проводити запис у червоно-чорне дерево, а також зчитування та видалення елементів з дерева.
Створено тестову програму, яка створює файловий дескриптор, відкриває його, пише\зчитує в\з нього дані, змінює розмір буферу, та прикріплює до буферу магічну фразу.
*Результат роботи тестової програми:*

   .. code-block:: C
   
   
       write return: offset=32, message=Wow, we made these bees TWERK !
       read return: offset=32, message=Wow, we made these bees TWERK !
       buf size change to 100
       write return: offset=51
       read return: offset=51, message=Wow, we made these bees TWERK ! Let's intrude them
       Return from read callback: offset=100, message=Wow, we made these bees TWERK ! Let's intrude themWow, we made these bees TWERK !

       [  336.202857] hivemod: Seeking to position: 0

       [  336.202862] hivemod: read 51 bytes from position: 0

       [  336.202887] hivemod: Seeking to position: 0

       [  336.202893] hivemod: read 100 bytes from position: 0

       [  336.202916] hivemod: File entry 000000007158f2b2 unlinked
       
       
Висновки
--------

Було модифіковано отриманий від викладача символьний пристрій, який ще можна назвати scull, тому що ций пристрій не потребує
прямої взаємодії з залізом, і використовує лише пам'ять системи.
Заглиблюючись далі у світ *kernel linux* стає зрозумілішою та прозорішою архітектура UNIX-подібних систем, що на мій погляд - захоплююче, адже використовуючи надане ядром API, можна створити свою кастомну, унікальну систему!

